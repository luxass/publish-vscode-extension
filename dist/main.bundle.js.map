{"version":3,"file":"main.bundle.js","sources":["webpack://action-publish-vscode-extension/./src/constants.ts","webpack://action-publish-vscode-extension/./src/vsce/version-bump.ts","webpack://action-publish-vscode-extension/./src/vsce/util.ts","webpack://action-publish-vscode-extension/./src/vsce/package.ts","webpack://action-publish-vscode-extension/./src/vsix.ts","webpack://action-publish-vscode-extension/./src/index.ts"],"sourcesContent":["export const REGISTRIES = {\n\t\"open-vsx\": \"https://open-vsx.org\",\n\t\"vs-marketplace\": \"https://marketplace.visualstudio.com\",\n}\n","import { promisify } from \"node:util\";\nimport * as cp from \"node:child_process\";\nimport * as semver from \"semver\";\nimport type { Manifest } from \"./manifest\";\n\nexport interface IVersionBumpOptions {\n\treadonly cwd?: string;\n\treadonly version?: string;\n\treadonly commitMessage?: string;\n\treadonly gitTagVersion?: boolean;\n\treadonly updatePackageJson?: boolean;\n}\n\n/**\n * @see https://github.com/microsoft/vscode-vsce/blob/7d1cc98c297f764fe15f2a189392c22c7242fabb/src/package.ts#L350\n */\nexport async function versionBump(manifest: Manifest, options: IVersionBumpOptions): Promise<void> {\n\tif (!options.version) {\n\t\treturn;\n\t}\n\n\tif (!(options.updatePackageJson ?? true)) {\n\t\treturn;\n\t}\n\n\tif (manifest.version === options.version) {\n\t\treturn;\n\t}\n\n\t// update the manifest object\n\tconst manifestVersion = manifest.version;\n\tconst today = new Date().getTime().toString().slice(0, 8);\n\tconst currentVersion = semver.valid(manifestVersion);\n\n\tif (!currentVersion) {\n\t\tthrow new Error(\"Cannot get the current version number from package.json\");\n\t}\n\n\tconst rcVersion =\n\t\toptions.version ?? semver.inc(currentVersion, \"minor\")?.replace(/\\.\\d+$/, `.${today}`);\n\tif (!rcVersion) {\n\t\tthrow new Error(\"Could not populate the current version number for rc's build.\");\n\t}\n\n\tif (rcVersion) {\n\t\tmanifest.version = rcVersion;\n\t\tconsole.log(`Bumped version from ${manifestVersion} to ${rcVersion}`);\n\t}\n\n\tlet command = `yarn version ${rcVersion}`;\n\n\tif (options.commitMessage) {\n\t\tcommand = `${command} -m \"${options.commitMessage}\"`;\n\t}\n\n\tif (!(options.gitTagVersion ?? true)) {\n\t\tcommand = `${command} --no-git-tag-version`;\n\t}\n\n\t// call `npm version` to do our dirty work\n\tconst cwd = options.cwd ?? process.cwd();\n\tconst { stdout, stderr } = await promisify(cp.exec)(command, { cwd });\n\n\tif (!process.env.VSCE_TESTS) {\n\t\tprocess.stdout.write(stdout);\n\t\tprocess.stderr.write(stderr);\n\t}\n}\n","import chalk from \"chalk\";\nimport { EOL } from \"node:os\";\nimport _read from \"read\";\nimport { promisify } from \"node:util\";\nimport type { Manifest } from \"./manifest\";\n\nconst __read = promisify<_read.Options, string>(_read);\nexport function read(prompt: string, options: _read.Options = {}): Promise<string> {\n\tif (process.env.VSCE_TESTS || !process.stdout.isTTY) {\n\t\treturn Promise.resolve(\"y\");\n\t}\n\n\treturn __read({ prompt, ...options });\n}\n\nconst marketplaceUrl =\n\tprocess.env.VSCE_MARKETPLACE_URL || \"https://marketplace.visualstudio.com\";\n\nexport function getPublishedUrl(extension: string): string {\n\treturn `${marketplaceUrl}/items?itemName=${extension}`;\n}\n\nexport function getHubUrl(publisher: string, name: string): string {\n\treturn `${marketplaceUrl}/manage/publishers/${publisher}/extensions/${name}/hub`;\n}\n\nexport function normalize(path: string): string {\n\treturn path.replace(/\\\\/g, \"/\");\n}\n\nfunction chain2<A, B>(a: A, b: B[], fn: (a: A, b: B) => Promise<A>, index = 0): Promise<A> {\n\tif (index >= b.length) {\n\t\treturn Promise.resolve(a);\n\t}\n\n\t// @ts-ignore\n\treturn fn(a, b[index]).then((a) => chain2(a, b, fn, index + 1));\n}\n\nexport function chain<T, P>(\n\tinitial: T,\n\tprocessors: P[],\n\tprocess: (a: T, b: P) => Promise<T>,\n): Promise<T> {\n\treturn chain2(initial, processors, process);\n}\n\nexport function flatten<T>(arr: T[][]): T[] {\n\treturn ([] as T[]).concat.apply([], arr) as T[];\n}\n\nexport function nonnull<T>(arg: T | null | undefined): arg is T {\n\treturn !!arg;\n}\n\nconst CancelledError = \"Cancelled\";\n\nexport function isCancelledError(error: any) {\n\treturn error === CancelledError;\n}\n\nexport class CancellationToken {\n\tprivate listeners: Function[] = [];\n\tprivate _cancelled = false;\n\tget isCancelled(): boolean {\n\t\treturn this._cancelled;\n\t}\n\n\tsubscribe(fn: Function): Function {\n\t\tthis.listeners.push(fn);\n\n\t\treturn () => {\n\t\t\tconst index = this.listeners.indexOf(fn);\n\n\t\t\tif (index > -1) {\n\t\t\t\tthis.listeners.splice(index, 1);\n\t\t\t}\n\t\t};\n\t}\n\n\tcancel(): void {\n\t\tconst emit = !this._cancelled;\n\t\tthis._cancelled = true;\n\n\t\tif (emit) {\n\t\t\tthis.listeners.forEach((l) => l(CancelledError));\n\t\t\tthis.listeners = [];\n\t\t}\n\t}\n}\n\nexport async function sequence(promiseFactories: (() => Promise<any>)[]): Promise<void> {\n\tfor (const factory of promiseFactories) {\n\t\tawait factory();\n\t}\n}\n\nenum LogMessageType {\n\tDONE = 0,\n\tINFO = 1,\n\tWARNING = 2,\n\tERROR = 3,\n}\n\nconst LogPrefix = {\n\t[LogMessageType.DONE]: chalk.bgGreen.black(\" DONE \"),\n\t[LogMessageType.INFO]: chalk.bgBlueBright.black(\" INFO \"),\n\t[LogMessageType.WARNING]: chalk.bgYellow.black(\" WARNING \"),\n\t[LogMessageType.ERROR]: chalk.bgRed.black(\" ERROR \"),\n};\n\nfunction _log(type: LogMessageType, msg: any, ...args: any[]): void {\n\targs = [LogPrefix[type], msg, ...args];\n\n\tif (type === LogMessageType.WARNING) {\n\t\tprocess.env[\"GITHUB_ACTIONS\"] ? logToGitHubActions(\"warning\", msg) : console.warn(...args);\n\t} else if (type === LogMessageType.ERROR) {\n\t\tprocess.env[\"GITHUB_ACTIONS\"] ? logToGitHubActions(\"error\", msg) : console.error(...args);\n\t} else {\n\t\tprocess.env[\"GITHUB_ACTIONS\"] ? logToGitHubActions(\"info\", msg) : console.log(...args);\n\t}\n}\n\nconst EscapeCharacters = new Map([\n\t[\"%\", \"%25\"],\n\t[\"\\r\", \"%0D\"],\n\t[\"\\n\", \"%0A\"],\n]);\n\nconst EscapeRegex = new RegExp(`[${[...EscapeCharacters.keys()].join(\"\")}]`, \"g\");\n\nfunction escapeGitHubActionsMessage(message: string): string {\n\treturn message.replace(EscapeRegex, (c) => EscapeCharacters.get(c) ?? c);\n}\n\nfunction logToGitHubActions(type: string, message: string): void {\n\tconst command = type === \"info\" ? message : `::${type}::${escapeGitHubActionsMessage(message)}`;\n\tprocess.stdout.write(command + EOL);\n}\n\nexport type LogFn = (msg: any, ...args: any[]) => void;\n\nexport const log = {\n\tdone: _log.bind(null, LogMessageType.DONE) as LogFn,\n\tinfo: _log.bind(null, LogMessageType.INFO) as LogFn,\n\twarn: _log.bind(null, LogMessageType.WARNING) as LogFn,\n\terror: _log.bind(null, LogMessageType.ERROR) as LogFn,\n};\n\nexport function patchOptionsWithManifest(options: any, manifest: Manifest): void {\n\tif (!manifest.vsce) {\n\t\treturn;\n\t}\n\n\tfor (const key of Object.keys(manifest.vsce)) {\n\t\tconst optionsKey = key === \"yarn\" ? \"useYarn\" : key;\n\n\t\tif (options[optionsKey] === undefined) {\n\t\t\toptions[optionsKey] = manifest.vsce[key];\n\t\t}\n\t}\n}\n","import * as cheerio from \"cheerio\";\nimport * as fs from \"node:fs\";\nimport * as GitHost from \"hosted-git-info\";\nimport markdownit from \"markdown-it\";\nimport mime from \"mime\";\nimport parseSemver from \"parse-semver\";\nimport { join, extname, normalize } from \"pathe\";\nimport * as semver from \"semver\";\nimport * as url from \"node:url\";\nimport * as yazl from \"yazl\";\nimport type { ExtensionKind, Manifest } from \"./manifest\";\nimport * as util from \"./util\";\n\ninterface IInMemoryFile {\n\tpath: string;\n\tmode?: number;\n\treadonly contents: Buffer | string;\n}\n\ninterface ILocalFile {\n\tpath: string;\n\tmode?: number;\n\treadonly localPath: string;\n}\n\nexport type IFile = IInMemoryFile | ILocalFile;\n\nfunction isInMemoryFile(file: IFile): file is IInMemoryFile {\n\treturn !!(file as IInMemoryFile).contents;\n}\n\nfunction read(file: IFile): Promise<string> {\n\tif (isInMemoryFile(file)) {\n\t\treturn Promise.resolve(file.contents).then((b) =>\n\t\t\ttypeof b === \"string\" ? b : b.toString(\"utf8\"),\n\t\t);\n\t} else {\n\t\treturn fs.promises.readFile(file.localPath, \"utf8\");\n\t}\n}\n\ninterface IAsset {\n\ttype: string;\n\tpath: string;\n}\n\n/**\n * Options for the `createVSIX` function.\n * @public\n */\nexport interface IPackageOptions {\n\t/**\n\t * The destination of the packaged the VSIX.\n\t *\n\t * Defaults to `NAME-VERSION.vsix`.\n\t */\n\treadonly packagePath?: string;\n\treadonly version?: string;\n\n\t/**\n\t * Optional target the extension should run on.\n\t *\n\t * https://code.visualstudio.com/api/working-with-extensions/publishing-extension#platformspecific-extensions\n\t */\n\treadonly target?: string;\n\treadonly commitMessage?: string;\n\treadonly gitTagVersion?: boolean;\n\treadonly updatePackageJson?: boolean;\n\n\t/**\n\t * The location of the extension in the file system.\n\t *\n\t * Defaults to `process.cwd()`.\n\t */\n\treadonly cwd?: string;\n\n\t/**\n\t * GitHub branch used to publish the package. Used to automatically infer\n\t * the base content and images URI.\n\t */\n\treadonly githubBranch?: string;\n\n\t/**\n\t * GitLab branch used to publish the package. Used to automatically infer\n\t * the base content and images URI.\n\t */\n\treadonly gitlabBranch?: string;\n\n\treadonly rewriteRelativeLinks?: boolean;\n\t/**\n\t * The base URL for links detected in Markdown files.\n\t */\n\treadonly baseContentUrl?: string;\n\n\t/**\n\t * The base URL for images detected in Markdown files.\n\t */\n\treadonly baseImagesUrl?: string;\n\n\t/**\n\t * Should use Yarn instead of NPM.\n\t */\n\treadonly useYarn?: boolean;\n\treadonly dependencyEntryPoints?: string[];\n\treadonly ignoreFile?: string;\n\treadonly gitHubIssueLinking?: boolean;\n\treadonly gitLabIssueLinking?: boolean;\n\treadonly dependencies?: boolean;\n\n\t/**\n\t * Mark this package as a pre-release\n\t */\n\treadonly preRelease?: boolean;\n\treadonly allowStarActivation?: boolean;\n\treadonly allowMissingRepository?: boolean;\n}\n\ninterface IProcessor {\n\tonFile(file: IFile): Promise<IFile>;\n\tonEnd(): Promise<void>;\n\tassets: IAsset[];\n\ttags: string[];\n\tvsix: any;\n}\n\ninterface VSIX {\n\tid: string;\n\tdisplayName: string;\n\tversion: string;\n\tpublisher: string;\n\ttarget?: string;\n\tengine: string;\n\tdescription: string;\n\tcategories: string;\n\tflags: string;\n\ticon?: string;\n\tlicense?: string;\n\tassets: IAsset[];\n\ttags: string;\n\tlinks: {\n\t\trepository?: string;\n\t\tbugs?: string;\n\t\thomepage?: string;\n\t\tgithub?: string;\n\t};\n\tgalleryBanner: NonNullable<Manifest[\"galleryBanner\"]>;\n\tbadges?: Manifest[\"badges\"];\n\tgithubMarkdown: boolean;\n\tenableMarketplaceQnA?: boolean;\n\tcustomerQnALink?: Manifest[\"qna\"];\n\textensionDependencies: string;\n\textensionPack: string;\n\textensionKind: string;\n\tlocalizedLanguages: string;\n\tpreRelease: boolean;\n\tsponsorLink: string;\n\tpricing: string;\n}\n\nclass BaseProcessor implements IProcessor {\n\tconstructor(protected manifest: Manifest) {}\n\tassets: IAsset[] = [];\n\ttags: string[] = [];\n\tvsix: VSIX = Object.create(null);\n\tasync onFile(file: IFile): Promise<IFile> {\n\t\treturn file;\n\t}\n\tasync onEnd() {\n\t\t// noop\n\t}\n}\n\n// https://github.com/npm/cli/blob/latest/lib/utils/hosted-git-info-from-manifest.js\nfunction getGitHost(manifest: Manifest): GitHost | undefined {\n\tconst url = getRepositoryUrl(manifest);\n\treturn url ? GitHost.fromUrl(url, { noGitPlus: true }) : undefined;\n}\n\n// https://github.com/npm/cli/blob/latest/lib/repo.js\nfunction getRepositoryUrl(manifest: Manifest, gitHost?: GitHost | null): string | undefined {\n\tif (gitHost) {\n\t\treturn gitHost.https();\n\t}\n\n\tlet url: string | undefined = undefined;\n\n\tif (manifest.repository) {\n\t\tif (typeof manifest.repository === \"string\") {\n\t\t\turl = manifest.repository;\n\t\t} else if (\n\t\t\ttypeof manifest.repository === \"object\" &&\n\t\t\tmanifest.repository.url &&\n\t\t\ttypeof manifest.repository.url === \"string\"\n\t\t) {\n\t\t\turl = manifest.repository.url;\n\t\t}\n\t}\n\n\treturn url;\n}\n\n// https://github.com/npm/cli/blob/latest/lib/bugs.js\nfunction getBugsUrl(manifest: Manifest, gitHost: GitHost | undefined): string | undefined {\n\tif (manifest.bugs) {\n\t\tif (typeof manifest.bugs === \"string\") {\n\t\t\treturn manifest.bugs;\n\t\t}\n\t\tif (typeof manifest.bugs === \"object\" && manifest.bugs.url) {\n\t\t\treturn manifest.bugs.url;\n\t\t}\n\t\tif (typeof manifest.bugs === \"object\" && manifest.bugs.email) {\n\t\t\treturn `mailto:${manifest.bugs.email}`;\n\t\t}\n\t}\n\n\tif (gitHost) {\n\t\treturn gitHost.bugs();\n\t}\n\n\treturn undefined;\n}\n\n// https://github.com/npm/cli/blob/latest/lib/docs.js\nfunction getHomepageUrl(manifest: Manifest, gitHost: GitHost | undefined): string | undefined {\n\tif (manifest.homepage) {\n\t\treturn manifest.homepage;\n\t}\n\n\tif (gitHost) {\n\t\treturn gitHost.docs();\n\t}\n\n\treturn undefined;\n}\n\n// Contributed by Mozilla developer authors\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions\nfunction escapeRegExp(value: string) {\n\treturn value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"); // $& means the whole matched string\n}\n\nfunction toExtensionTags(extensions: string[]): string[] {\n\treturn extensions\n\t\t.map((s) => s.replace(/\\W/g, \"\"))\n\t\t.filter((s) => !!s)\n\t\t.map((s) => `__ext_${s}`);\n}\n\nfunction toLanguagePackTags(translations: { id: string }[], languageId: string): string[] {\n\treturn (translations ?? [])\n\t\t.map(({ id }) => [`__lp_${id}`, `__lp-${languageId}_${id}`])\n\t\t.reduce((r, t) => [...r, ...t], []);\n}\n\n/* This list is also maintained by the Marketplace team.\n * Remember to reach out to them when adding new domains.\n */\nconst TrustedSVGSources = [\n\t\"api.bintray.com\",\n\t\"api.travis-ci.com\",\n\t\"api.travis-ci.org\",\n\t\"app.fossa.io\",\n\t\"badge.buildkite.com\",\n\t\"badge.fury.io\",\n\t\"badge.waffle.io\",\n\t\"badgen.net\",\n\t\"badges.frapsoft.com\",\n\t\"badges.gitter.im\",\n\t\"badges.greenkeeper.io\",\n\t\"cdn.travis-ci.com\",\n\t\"cdn.travis-ci.org\",\n\t\"ci.appveyor.com\",\n\t\"circleci.com\",\n\t\"cla.opensource.microsoft.com\",\n\t\"codacy.com\",\n\t\"codeclimate.com\",\n\t\"codecov.io\",\n\t\"coveralls.io\",\n\t\"david-dm.org\",\n\t\"deepscan.io\",\n\t\"dev.azure.com\",\n\t\"docs.rs\",\n\t\"flat.badgen.net\",\n\t\"gemnasium.com\",\n\t\"githost.io\",\n\t\"gitlab.com\",\n\t\"godoc.org\",\n\t\"goreportcard.com\",\n\t\"img.shields.io\",\n\t\"isitmaintained.com\",\n\t\"marketplace.visualstudio.com\",\n\t\"nodesecurity.io\",\n\t\"opencollective.com\",\n\t\"snyk.io\",\n\t\"travis-ci.com\",\n\t\"travis-ci.org\",\n\t\"visualstudio.com\",\n\t\"vsmarketplacebadges.dev\",\n\t\"www.bithound.io\",\n\t\"www.versioneye.com\",\n];\n\nfunction isGitHubRepository(repository: string | undefined): boolean {\n\treturn /^https:\\/\\/github\\.com\\/|^git@github\\.com:/.test(repository ?? \"\");\n}\n\nfunction isGitLabRepository(repository: string | undefined): boolean {\n\treturn /^https:\\/\\/gitlab\\.com\\/|^git@gitlab\\.com:/.test(repository ?? \"\");\n}\n\nfunction isGitHubBadge(href: string): boolean {\n\treturn /^https:\\/\\/github\\.com\\/[^/]+\\/[^/]+\\/(actions\\/)?workflows\\/.*badge\\.svg/.test(\n\t\thref || \"\",\n\t);\n}\n\nfunction isHostTrusted(url: url.URL): boolean {\n\treturn (\n\t\t(url.host && TrustedSVGSources.indexOf(url.host.toLowerCase()) > -1) || isGitHubBadge(url.href)\n\t);\n}\n\nexport const Targets = new Set([\n\t\"win32-x64\",\n\t\"win32-arm64\",\n\t\"linux-x64\",\n\t\"linux-arm64\",\n\t\"linux-armhf\",\n\t\"darwin-x64\",\n\t\"darwin-arm64\",\n\t\"alpine-x64\",\n\t\"alpine-arm64\",\n\t\"web\",\n]);\n\nclass ManifestProcessor extends BaseProcessor {\n\tconstructor(\n\t\tmanifest: Manifest,\n\t\tprivate readonly options: IPackageOptions = {},\n\t) {\n\t\tsuper(manifest);\n\n\t\tconst flags = [\"Public\"];\n\n\t\tif (manifest.preview) {\n\t\t\tflags.push(\"Preview\");\n\t\t}\n\n\t\tconst gitHost = getGitHost(manifest);\n\t\tconst repository = getRepositoryUrl(manifest, gitHost);\n\t\tconst isGitHub = isGitHubRepository(repository);\n\n\t\tlet enableMarketplaceQnA: boolean | undefined;\n\t\tlet customerQnALink: string | undefined;\n\n\t\tif (manifest.qna === \"marketplace\") {\n\t\t\tenableMarketplaceQnA = true;\n\t\t} else if (typeof manifest.qna === \"string\") {\n\t\t\tcustomerQnALink = manifest.qna;\n\t\t} else if (manifest.qna === false) {\n\t\t\tenableMarketplaceQnA = false;\n\t\t}\n\n\t\tconst extensionKind = getExtensionKind(manifest);\n\t\tconst target = options.target;\n\t\tconst preRelease = options.preRelease;\n\n\t\tif (target || preRelease) {\n\t\t\tlet engineVersion: string;\n\n\t\t\ttry {\n\t\t\t\tconst engineSemver = parseSemver(`vscode@${manifest.engines[\"vscode\"]}`);\n\t\t\t\tengineVersion = engineSemver.version;\n\t\t\t} catch (err) {\n\t\t\t\tthrow new Error(\"Failed to parse semver of engines.vscode\");\n\t\t\t}\n\n\t\t\tif (target) {\n\t\t\t\tif (\n\t\t\t\t\tengineVersion !== \"latest\" &&\n\t\t\t\t\t!semver.satisfies(engineVersion, \">=1.61\", { includePrerelease: true })\n\t\t\t\t) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Platform specific extension is supported by VS Code >=1.61. Current 'engines.vscode' is '${manifest.engines.vscode}'.`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif (!Targets.has(target)) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`'${target}' is not a valid VS Code target. Valid targets: ${[...Targets].join(\", \")}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (preRelease) {\n\t\t\t\tif (\n\t\t\t\t\tengineVersion !== \"latest\" &&\n\t\t\t\t\t!semver.satisfies(engineVersion, \">=1.63\", { includePrerelease: true })\n\t\t\t\t) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Pre-release versions are supported by VS Code >=1.63. Current 'engines.vscode' is '${manifest.engines.vscode}'.`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.vsix = {\n\t\t\t...this.vsix,\n\t\t\tid: manifest.name,\n\t\t\tdisplayName: manifest.displayName ?? manifest.name,\n\t\t\tversion:\n\t\t\t\toptions.version && !(options.updatePackageJson ?? true)\n\t\t\t\t\t? options.version\n\t\t\t\t\t: manifest.version,\n\t\t\tpublisher: manifest.publisher,\n\t\t\ttarget,\n\t\t\t// @ts-ignore\n\t\t\tengine: manifest.engines.vscode,\n\t\t\tdescription: manifest.description ?? \"\",\n\t\t\tpricing: manifest.pricing ?? \"Free\",\n\t\t\tcategories: (manifest.categories ?? []).join(\",\"),\n\t\t\tflags: flags.join(\" \"),\n\t\t\tlinks: {\n\t\t\t\trepository,\n\t\t\t\tbugs: getBugsUrl(manifest, gitHost),\n\t\t\t\thomepage: getHomepageUrl(manifest, gitHost),\n\t\t\t},\n\t\t\tgalleryBanner: manifest.galleryBanner ?? {},\n\t\t\tbadges: manifest.badges,\n\t\t\tgithubMarkdown: manifest.markdown !== \"standard\",\n\t\t\tenableMarketplaceQnA,\n\t\t\tcustomerQnALink,\n\t\t\textensionDependencies: [...new Set(manifest.extensionDependencies ?? [])].join(\",\"),\n\t\t\textensionPack: [...new Set(manifest.extensionPack ?? [])].join(\",\"),\n\t\t\textensionKind: extensionKind.join(\",\"),\n\t\t\tlocalizedLanguages:\n\t\t\t\tmanifest.contributes && manifest.contributes.localizations\n\t\t\t\t\t? manifest.contributes.localizations\n\t\t\t\t\t\t\t.map((loc) => loc.localizedLanguageName ?? loc.languageName ?? loc.languageId)\n\t\t\t\t\t\t\t.join(\",\")\n\t\t\t\t\t: \"\",\n\t\t\tpreRelease: !!this.options.preRelease,\n\t\t\tsponsorLink: manifest.sponsor?.url || \"\",\n\t\t};\n\n\t\tif (isGitHub) {\n\t\t\tthis.vsix.links.github = repository;\n\t\t}\n\t}\n\n\tasync onFile(file: IFile): Promise<IFile> {\n\t\tconst path = util.normalize(file.path);\n\n\t\tif (!/^extension\\/package.json$/i.test(path)) {\n\t\t\treturn Promise.resolve(file);\n\t\t}\n\n\t\tif (this.options.version && (this.options.updatePackageJson ?? true)) {\n\t\t\tconst contents = await read(file);\n\t\t\tconst packageJson = JSON.parse(contents);\n\t\t\tpackageJson.bundledDependencies = [];\n\t\t\tfile = { ...file, contents: JSON.stringify(packageJson, undefined, 2) };\n\t\t}\n\n\t\t// Ensure that package.json is writable as VS Code needs to\n\t\t// store metadata in the extracted file.\n\t\treturn { ...file, mode: 0o100644 };\n\t}\n\n\tasync onEnd(): Promise<void> {\n\t\tif (typeof this.manifest.extensionKind === \"string\") {\n\t\t\tutil.log.warn(\n\t\t\t\t`The 'extensionKind' property should be of type 'string[]'. Learn more at: https://aka.ms/vscode/api/incorrect-execution-location`,\n\t\t\t);\n\t\t}\n\n\t\tif (this.manifest.publisher === \"vscode-samples\") {\n\t\t\tthrow new Error(\n\t\t\t\t\"It's not allowed to use the 'vscode-samples' publisher. Learn more at: https://code.visualstudio.com/api/working-with-extensions/publishing-extension.\",\n\t\t\t);\n\t\t}\n\n\t\tif (!this.options.allowMissingRepository && !this.manifest.repository) {\n\t\t\tutil.log.warn(`A 'repository' field is missing from the 'package.json' manifest file.`);\n\n\t\t\tif (!/^y$/i.test(await util.read(\"Do you want to continue? [y/N] \"))) {\n\t\t\t\tthrow new Error(\"Aborted\");\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\t!this.options.allowStarActivation &&\n\t\t\tthis.manifest.activationEvents?.some((e) => e === \"*\")\n\t\t) {\n\t\t\tutil.log.warn(\n\t\t\t\t`Using '*' activation is usually a bad idea as it impacts performance.\\nMore info: https://code.visualstudio.com/api/references/activation-events#Start-up`,\n\t\t\t);\n\n\t\t\tif (!/^y$/i.test(await util.read(\"Do you want to continue? [y/N] \"))) {\n\t\t\t\tthrow new Error(\"Aborted\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass TagsProcessor extends BaseProcessor {\n\tprivate static Keywords: Record<string, string[]> = {\n\t\tgit: [\"git\"],\n\t\tnpm: [\"node\"],\n\t\tspell: [\"markdown\"],\n\t\tbootstrap: [\"bootstrap\"],\n\t\tlint: [\"linters\"],\n\t\tlinting: [\"linters\"],\n\t\treact: [\"javascript\"],\n\t\tjs: [\"javascript\"],\n\t\tnode: [\"javascript\", \"node\"],\n\t\t\"c++\": [\"c++\"],\n\t\tCplusplus: [\"c++\"],\n\t\txml: [\"xml\"],\n\t\tangular: [\"javascript\"],\n\t\tjquery: [\"javascript\"],\n\t\tphp: [\"php\"],\n\t\tpython: [\"python\"],\n\t\tlatex: [\"latex\"],\n\t\truby: [\"ruby\"],\n\t\tjava: [\"java\"],\n\t\terlang: [\"erlang\"],\n\t\tsql: [\"sql\"],\n\t\tnodejs: [\"node\"],\n\t\t\"c#\": [\"c#\"],\n\t\tcss: [\"css\"],\n\t\tjavascript: [\"javascript\"],\n\t\tftp: [\"ftp\"],\n\t\thaskell: [\"haskell\"],\n\t\tunity: [\"unity\"],\n\t\tterminal: [\"terminal\"],\n\t\tpowershell: [\"powershell\"],\n\t\tlaravel: [\"laravel\"],\n\t\tmeteor: [\"meteor\"],\n\t\temmet: [\"emmet\"],\n\t\teslint: [\"linters\"],\n\t\ttfs: [\"tfs\"],\n\t\trust: [\"rust\"],\n\t};\n\n\tasync onEnd(): Promise<void> {\n\t\tconst keywords = this.manifest.keywords ?? [];\n\t\tconst contributes = this.manifest.contributes;\n\t\tconst activationEvents = this.manifest.activationEvents ?? [];\n\t\tconst doesContribute = (...properties: string[]) => {\n\t\t\tlet obj = contributes;\n\t\t\tfor (const property of properties) {\n\t\t\t\tif (!obj) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tobj = obj[property];\n\t\t\t}\n\t\t\treturn obj && obj.length > 0;\n\t\t};\n\n\t\tconst colorThemes = doesContribute(\"themes\") ? [\"theme\", \"color-theme\"] : [];\n\t\tconst iconThemes = doesContribute(\"iconThemes\") ? [\"theme\", \"icon-theme\"] : [];\n\t\tconst productIconThemes = doesContribute(\"productIconThemes\")\n\t\t\t? [\"theme\", \"product-icon-theme\"]\n\t\t\t: [];\n\t\tconst snippets = doesContribute(\"snippets\") ? [\"snippet\"] : [];\n\t\tconst keybindings = doesContribute(\"keybindings\") ? [\"keybindings\"] : [];\n\t\tconst debuggers = doesContribute(\"debuggers\") ? [\"debuggers\"] : [];\n\t\tconst json = doesContribute(\"jsonValidation\") ? [\"json\"] : [];\n\t\tconst remoteMenu = doesContribute(\"menus\", \"statusBar/remoteIndicator\") ? [\"remote-menu\"] : [];\n\n\t\tconst localizationContributions = ((contributes && contributes[\"localizations\"]) ?? []).reduce<\n\t\t\tstring[]\n\t\t>(\n\t\t\t(r, l) => [...r, `lp-${l.languageId}`, ...toLanguagePackTags(l.translations, l.languageId)],\n\t\t\t[],\n\t\t);\n\n\t\tconst languageContributions = ((contributes && contributes[\"languages\"]) ?? []).reduce<\n\t\t\tstring[]\n\t\t>((r, l) => [...r, l.id, ...(l.aliases ?? []), ...toExtensionTags(l.extensions ?? [])], []);\n\n\t\tconst languageActivations = activationEvents\n\t\t\t.map((e) => /^onLanguage:(.*)$/.exec(e))\n\t\t\t.filter(util.nonnull)\n\t\t\t.map((r) => r[1]);\n\n\t\tconst grammars = ((contributes && contributes[\"grammars\"]) ?? []).map((g) => g.language);\n\n\t\tconst description = this.manifest.description || \"\";\n\t\tconst descriptionKeywords = Object.keys(TagsProcessor.Keywords).reduce<string[]>(\n\t\t\t(r, k) =>\n\t\t\t\tr.concat(\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tnew RegExp(\"\\\\b(?:\" + escapeRegExp(k) + \")(?!\\\\w)\", \"gi\").test(description)\n\t\t\t\t\t\t? TagsProcessor.Keywords[k]\n\t\t\t\t\t\t: [],\n\t\t\t\t),\n\t\t\t[],\n\t\t);\n\n\t\tconst webExtensionTags = isWebKind(this.manifest) ? [\"__web_extension\"] : [];\n\t\tconst sponsorTags = this.manifest.sponsor?.url ? [\"__sponsor_extension\"] : [];\n\n\t\tconst tags = new Set([\n\t\t\t...keywords,\n\t\t\t...colorThemes,\n\t\t\t...iconThemes,\n\t\t\t...productIconThemes,\n\t\t\t...snippets,\n\t\t\t...keybindings,\n\t\t\t...debuggers,\n\t\t\t...json,\n\t\t\t...remoteMenu,\n\t\t\t...localizationContributions,\n\t\t\t...languageContributions,\n\t\t\t...languageActivations,\n\t\t\t...grammars,\n\t\t\t...descriptionKeywords,\n\t\t\t...webExtensionTags,\n\t\t\t...sponsorTags,\n\t\t]);\n\n\t\t// @ts-ignore\n\t\tthis.tags = [...tags].filter((tag) => !!tag);\n\t}\n}\n\nclass MarkdownProcessor extends BaseProcessor {\n\tprivate baseContentUrl: string | undefined;\n\tprivate baseImagesUrl: string | undefined;\n\tprivate rewriteRelativeLinks: boolean;\n\tprivate isGitHub: boolean;\n\tprivate isGitLab: boolean;\n\tprivate repositoryUrl: string | undefined;\n\tprivate gitHubIssueLinking: boolean;\n\tprivate gitLabIssueLinking: boolean;\n\n\tconstructor(\n\t\tmanifest: Manifest,\n\t\tprivate name: string,\n\t\tprivate regexp: RegExp,\n\t\tprivate assetType: string,\n\t\toptions: IPackageOptions = {},\n\t) {\n\t\tsuper(manifest);\n\n\t\tconst guess = this.guessBaseUrls(options.githubBranch || options.gitlabBranch);\n\n\t\tthis.baseContentUrl = options.baseContentUrl || (guess && guess.content);\n\t\tthis.baseImagesUrl = options.baseImagesUrl || options.baseContentUrl || (guess && guess.images);\n\t\tthis.rewriteRelativeLinks = options.rewriteRelativeLinks ?? true;\n\t\tthis.repositoryUrl = guess && guess.repository;\n\t\tthis.isGitHub = isGitHubRepository(this.repositoryUrl);\n\t\tthis.isGitLab = isGitLabRepository(this.repositoryUrl);\n\t\tthis.gitHubIssueLinking =\n\t\t\ttypeof options.gitHubIssueLinking === \"boolean\" ? options.gitHubIssueLinking : true;\n\t\tthis.gitLabIssueLinking =\n\t\t\ttypeof options.gitLabIssueLinking === \"boolean\" ? options.gitLabIssueLinking : true;\n\t}\n\n\tasync onFile(file: IFile): Promise<IFile> {\n\t\t// @ts-ignore\n\t\tconst urljoin = (await import(\"url-join\")).default;\n\t\tconst filePath = util.normalize(file.path);\n\n\t\tif (!this.regexp.test(filePath)) {\n\t\t\treturn Promise.resolve(file);\n\t\t}\n\n\t\tthis.assets.push({ type: this.assetType, path: filePath });\n\n\t\tlet contents = await read(file);\n\n\t\tif (/This is the README for your extension /.test(contents)) {\n\t\t\tthrow new Error(\n\t\t\t\t`It seems the README.md still contains template text. Make sure to edit the README.md file before you package or publish your extension.`,\n\t\t\t);\n\t\t}\n\n\t\tif (this.rewriteRelativeLinks) {\n\t\t\t// eslint-disable-next-line no-useless-escape\n\t\t\tconst markdownPathRegex = /(!?)\\[([^\\]\\[]*|!\\[[^\\]\\[]*]\\([^\\)]+\\))\\]\\(([^\\)]+)\\)/g;\n\t\t\tconst urlReplace = (_: string, isImage: string, title: string, link: string) => {\n\t\t\t\tif (/^mailto:/i.test(link)) {\n\t\t\t\t\treturn `${isImage}[${title}](${link})`;\n\t\t\t\t}\n\n\t\t\t\tconst isLinkRelative = !/^\\w+:\\/\\//.test(link) && link[0] !== \"#\";\n\n\t\t\t\tif (!this.baseContentUrl && !this.baseImagesUrl) {\n\t\t\t\t\tconst asset = isImage ? \"image\" : \"link\";\n\n\t\t\t\t\tif (isLinkRelative) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Couldn't detect the repository where this extension is published. The ${asset} '${link}' will be broken in ${this.name}. GitHub/GitLab repositories will be automatically detected. Otherwise, please provide the repository URL in package.json or use the --baseContentUrl and --baseImagesUrl options.`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttitle = title.replace(markdownPathRegex, urlReplace);\n\t\t\t\tconst prefix = isImage ? this.baseImagesUrl : this.baseContentUrl;\n\n\t\t\t\tif (!prefix || !isLinkRelative) {\n\t\t\t\t\treturn `${isImage}[${title}](${link})`;\n\t\t\t\t}\n\n\t\t\t\treturn `${isImage}[${title}](${urljoin(prefix, normalize(link))})`;\n\t\t\t};\n\n\t\t\t// Replace Markdown links with urls\n\t\t\tcontents = contents.replace(markdownPathRegex, urlReplace);\n\n\t\t\t// Replace <img> links with urls\n\t\t\tcontents = contents.replace(/<img.+?src=[\"']([/.\\w\\s#-]+)['\"].*?>/g, (all, link) => {\n\t\t\t\tconst isLinkRelative = !/^\\w+:\\/\\//.test(link) && link[0] !== \"#\";\n\n\t\t\t\tif (!this.baseImagesUrl && isLinkRelative) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Couldn't detect the repository where this extension is published. The image will be broken in ${this.name}. GitHub/GitLab repositories will be automatically detected. Otherwise, please provide the repository URL in package.json or use the --baseContentUrl and --baseImagesUrl options.`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tconst prefix = this.baseImagesUrl;\n\n\t\t\t\tif (!prefix || !isLinkRelative) {\n\t\t\t\t\treturn all;\n\t\t\t\t}\n\n\t\t\t\treturn all.replace(link, urljoin(prefix, normalize(link)));\n\t\t\t});\n\n\t\t\tif (\n\t\t\t\t(this.gitHubIssueLinking && this.isGitHub) ||\n\t\t\t\t(this.gitLabIssueLinking && this.isGitLab)\n\t\t\t) {\n\t\t\t\tconst markdownIssueRegex = /(\\s|\\n)([\\w\\d_-]+\\/[\\w\\d_-]+)?#(\\d+)\\b/g;\n\t\t\t\tconst issueReplace = (\n\t\t\t\t\tall: string,\n\t\t\t\t\tprefix: string,\n\t\t\t\t\townerAndRepositoryName: string,\n\t\t\t\t\tissueNumber: string,\n\t\t\t\t): string => {\n\t\t\t\t\tlet result = all;\n\t\t\t\t\tlet owner: string | undefined;\n\t\t\t\t\tlet repositoryName: string | undefined;\n\n\t\t\t\t\tif (ownerAndRepositoryName) {\n\t\t\t\t\t\t// prettier-ignore\n\t\t\t\t\t\t[owner, repositoryName] = ownerAndRepositoryName.split(\"/\", 2);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (owner && repositoryName && issueNumber) {\n\t\t\t\t\t\t// Issue in external repository\n\t\t\t\t\t\tconst issueUrl = this.isGitHub\n\t\t\t\t\t\t\t? urljoin(\"https://github.com\", owner, repositoryName, \"issues\", issueNumber)\n\t\t\t\t\t\t\t: urljoin(\"https://gitlab.com\", owner, repositoryName, \"-\", \"issues\", issueNumber);\n\t\t\t\t\t\tresult = prefix + `[${owner}/${repositoryName}#${issueNumber}](${issueUrl})`;\n\t\t\t\t\t} else if (!owner && !repositoryName && issueNumber && this.repositoryUrl) {\n\t\t\t\t\t\t// Issue in own repository\n\t\t\t\t\t\tresult =\n\t\t\t\t\t\t\tprefix +\n\t\t\t\t\t\t\t`[#${issueNumber}](${\n\t\t\t\t\t\t\t\tthis.isGitHub\n\t\t\t\t\t\t\t\t\t? urljoin(this.repositoryUrl, \"issues\", issueNumber)\n\t\t\t\t\t\t\t\t\t: urljoin(this.repositoryUrl, \"-\", \"issues\", issueNumber)\n\t\t\t\t\t\t\t})`;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\t\t\t\t// Replace Markdown issue references with urls\n\t\t\t\tcontents = contents.replace(markdownIssueRegex, issueReplace);\n\t\t\t}\n\t\t}\n\n\t\tconst html = markdownit({ html: true }).render(contents);\n\t\tconst $ = cheerio.load(html);\n\n\t\tif (this.rewriteRelativeLinks) {\n\t\t\t$(\"img\").each((_, img) => {\n\t\t\t\tconst rawSrc = $(img).attr(\"src\");\n\n\t\t\t\tif (!rawSrc) {\n\t\t\t\t\tthrow new Error(`Images in ${this.name} must have a source.`);\n\t\t\t\t}\n\n\t\t\t\tconst src = decodeURI(rawSrc);\n\t\t\t\tconst srcUrl = new url.URL(src);\n\n\t\t\t\tif (\n\t\t\t\t\t/^data:$/i.test(srcUrl.protocol) &&\n\t\t\t\t\t/^image$/i.test(srcUrl.host) &&\n\t\t\t\t\t/\\/svg/i.test(srcUrl.pathname)\n\t\t\t\t) {\n\t\t\t\t\tthrow new Error(`SVG data URLs are not allowed in ${this.name}: ${src}`);\n\t\t\t\t}\n\n\t\t\t\tif (!/^https:$/i.test(srcUrl.protocol)) {\n\t\t\t\t\tthrow new Error(`Images in ${this.name} must come from an HTTPS source: ${src}`);\n\t\t\t\t}\n\n\t\t\t\tif (/\\.svg$/i.test(srcUrl.pathname) && !isHostTrusted(srcUrl)) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`SVGs are restricted in ${this.name}; please use other file image formats, such as PNG: ${src}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t$(\"svg\").each(() => {\n\t\t\tthrow new Error(`SVG tags are not allowed in ${this.name}.`);\n\t\t});\n\n\t\treturn {\n\t\t\tpath: file.path,\n\t\t\tcontents: Buffer.from(contents, \"utf8\"),\n\t\t};\n\t}\n\n\t// GitHub heuristics\n\tprivate guessBaseUrls(\n\t\tgithostBranch: string | undefined,\n\t): { content: string; images: string; repository: string } | undefined {\n\t\tlet repository = null;\n\n\t\tif (typeof this.manifest.repository === \"string\") {\n\t\t\trepository = this.manifest.repository;\n\t\t} else if (this.manifest.repository && typeof this.manifest.repository[\"url\"] === \"string\") {\n\t\t\trepository = this.manifest.repository[\"url\"];\n\t\t}\n\n\t\tif (!repository) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst gitHubRegex = /(?<domain>github(\\.com\\/|:))(?<project>(?:[^/]+)\\/(?:[^/]+))(\\/|$)/;\n\t\tconst gitLabRegex = /(?<domain>gitlab(\\.com\\/|:))(?<project>(?:[^/]+)(\\/(?:[^/]+))+)(\\/|$)/;\n\t\tconst match = (gitHubRegex.exec(repository) || gitLabRegex.exec(repository)) as unknown as {\n\t\t\tgroups: Record<string, string>;\n\t\t};\n\n\t\tif (!match) {\n\t\t\treturn undefined;\n\t\t}\n\t\t// @ts-ignore\n\t\tconst project = match.groups.project.replace(/\\.git$/i, \"\");\n\t\tconst branchName = githostBranch ? githostBranch : \"HEAD\";\n\t\t// @ts-ignore\n\t\tif (/^github/.test(match.groups.domain)) {\n\t\t\treturn {\n\t\t\t\tcontent: `https://github.com/${project}/blob/${branchName}`,\n\t\t\t\timages: `https://github.com/${project}/raw/${branchName}`,\n\t\t\t\trepository: `https://github.com/${project}`,\n\t\t\t};\n\t\t// @ts-ignore\n\t\t} else if (/^gitlab/.test(match.groups.domain)) {\n\t\t\treturn {\n\t\t\t\tcontent: `https://gitlab.com/${project}/-/blob/${branchName}`,\n\t\t\t\timages: `https://gitlab.com/${project}/-/raw/${branchName}`,\n\t\t\t\trepository: `https://gitlab.com/${project}`,\n\t\t\t};\n\t\t}\n\n\t\treturn undefined;\n\t}\n}\n\nclass ReadmeProcessor extends MarkdownProcessor {\n\tconstructor(manifest: Manifest, options: IPackageOptions = {}) {\n\t\tsuper(\n\t\t\tmanifest,\n\t\t\t\"README.md\",\n\t\t\t/^extension\\/readme.md$/i,\n\t\t\t\"Microsoft.VisualStudio.Services.Content.Details\",\n\t\t\toptions,\n\t\t);\n\t}\n}\nclass ChangelogProcessor extends MarkdownProcessor {\n\tconstructor(manifest: Manifest, options: IPackageOptions = {}) {\n\t\tsuper(\n\t\t\tmanifest,\n\t\t\t\"CHANGELOG.md\",\n\t\t\t/^extension\\/changelog.md$/i,\n\t\t\t\"Microsoft.VisualStudio.Services.Content.Changelog\",\n\t\t\toptions,\n\t\t);\n\t}\n}\n\nclass LicenseProcessor extends BaseProcessor {\n\tprivate didFindLicense = false;\n\tprivate expectedLicenseName: string;\n\tfilter: (name: string) => boolean;\n\n\tconstructor(manifest: Manifest) {\n\t\tsuper(manifest);\n\n\t\tconst match = /^SEE LICENSE IN (.*)$/.exec(manifest.license || \"\");\n\n\t\tif (!match || !match[1]) {\n\t\t\tthis.expectedLicenseName = \"LICENSE.md, LICENSE.txt or LICENSE\";\n\t\t\tthis.filter = (name) => /^extension\\/license(\\.(md|txt))?$/i.test(name);\n\t\t} else {\n\t\t\tthis.expectedLicenseName = match[1];\n\t\t\tconst regexp = new RegExp(\"^extension/\" + match[1] + \"$\");\n\t\t\tthis.filter = regexp.test.bind(regexp);\n\t\t}\n\n\t\tdelete this.vsix.license;\n\t}\n\n\tonFile(file: IFile): Promise<IFile> {\n\t\tif (!this.didFindLicense) {\n\t\t\tlet normalizedPath = util.normalize(file.path);\n\n\t\t\tif (this.filter(normalizedPath)) {\n\t\t\t\tif (!extname(normalizedPath)) {\n\t\t\t\t\tfile.path += \".txt\";\n\t\t\t\t\tnormalizedPath += \".txt\";\n\t\t\t\t}\n\n\t\t\t\tthis.assets.push({\n\t\t\t\t\ttype: \"Microsoft.VisualStudio.Services.Content.License\",\n\t\t\t\t\tpath: normalizedPath,\n\t\t\t\t});\n\t\t\t\tthis.vsix.license = normalizedPath;\n\t\t\t\tthis.didFindLicense = true;\n\t\t\t}\n\t\t}\n\n\t\treturn Promise.resolve(file);\n\t}\n\n\tasync onEnd(): Promise<void> {\n\t\tif (!this.didFindLicense) {\n\t\t\tutil.log.warn(`${this.expectedLicenseName} not found`);\n\n\t\t\tif (!/^y$/i.test(await util.read(\"Do you want to continue? [y/N] \"))) {\n\t\t\t\tthrow new Error(\"Aborted\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass LaunchEntryPointProcessor extends BaseProcessor {\n\tprivate entryPoints: Set<string> = new Set<string>();\n\n\tconstructor(manifest: Manifest) {\n\t\tsuper(manifest);\n\t\tif (manifest.main) {\n\t\t\tthis.entryPoints.add(util.normalize(join(\"extension\", this.appendJSExt(manifest.main))));\n\t\t}\n\t\tif (manifest.browser) {\n\t\t\tthis.entryPoints.add(util.normalize(join(\"extension\", this.appendJSExt(manifest.browser))));\n\t\t}\n\t}\n\n\tappendJSExt(filePath: string): string {\n\t\tif (filePath.endsWith(\".js\") || filePath.endsWith(\".cjs\")) {\n\t\t\treturn filePath;\n\t\t}\n\t\treturn filePath + \".js\";\n\t}\n\n\tonFile(file: IFile): Promise<IFile> {\n\t\tthis.entryPoints.delete(util.normalize(file.path));\n\t\treturn Promise.resolve(file);\n\t}\n\n\tasync onEnd(): Promise<void> {\n\t\tif (this.entryPoints.size > 0) {\n\t\t\tconst files: string = [...this.entryPoints].join(\",\\n  \");\n\t\t\tthrow new Error(\n\t\t\t\t`Extension entrypoint(s) missing. Make sure these files exist and aren't ignored by '.vscodeignore':\\n  ${files}`,\n\t\t\t);\n\t\t}\n\t}\n}\n\nclass IconProcessor extends BaseProcessor {\n\tprivate icon: string | undefined;\n\tprivate didFindIcon = false;\n\n\tconstructor(manifest: Manifest) {\n\t\tsuper(manifest);\n\n\t\tthis.icon = manifest.icon && normalize(`extension/${manifest.icon}`);\n\t\tdelete this.vsix.icon;\n\t}\n\n\tonFile(file: IFile): Promise<IFile> {\n\t\tconst normalizedPath = util.normalize(file.path);\n\t\tif (normalizedPath === this.icon) {\n\t\t\tthis.didFindIcon = true;\n\t\t\tthis.assets.push({\n\t\t\t\ttype: \"Microsoft.VisualStudio.Services.Icons.Default\",\n\t\t\t\tpath: normalizedPath,\n\t\t\t});\n\t\t\tthis.vsix.icon = this.icon;\n\t\t}\n\t\treturn Promise.resolve(file);\n\t}\n\n\tasync onEnd(): Promise<void> {\n\t\tif (this.icon && !this.didFindIcon) {\n\t\t\treturn Promise.reject(\n\t\t\t\tnew Error(`The specified icon '${this.icon}' wasn't found in the extension.`),\n\t\t\t);\n\t\t}\n\t}\n}\n\nfunction isWebKind(manifest: Manifest): boolean {\n\tconst extensionKind = getExtensionKind(manifest);\n\treturn extensionKind.some((kind) => kind === \"web\");\n}\n\nconst extensionPointExtensionKindsMap = new Map<string, ExtensionKind[]>();\nextensionPointExtensionKindsMap.set(\"jsonValidation\", [\"workspace\", \"web\"]);\nextensionPointExtensionKindsMap.set(\"localizations\", [\"ui\", \"workspace\"]);\nextensionPointExtensionKindsMap.set(\"debuggers\", [\"workspace\"]);\nextensionPointExtensionKindsMap.set(\"terminal\", [\"workspace\"]);\nextensionPointExtensionKindsMap.set(\"typescriptServerPlugins\", [\"workspace\"]);\nextensionPointExtensionKindsMap.set(\"markdown.previewStyles\", [\"workspace\", \"web\"]);\nextensionPointExtensionKindsMap.set(\"markdown.previewScripts\", [\"workspace\", \"web\"]);\nextensionPointExtensionKindsMap.set(\"markdown.markdownItPlugins\", [\"workspace\", \"web\"]);\nextensionPointExtensionKindsMap.set(\"html.customData\", [\"workspace\", \"web\"]);\nextensionPointExtensionKindsMap.set(\"css.customData\", [\"workspace\", \"web\"]);\n\nfunction getExtensionKind(manifest: Manifest): ExtensionKind[] {\n\tconst deduced = deduceExtensionKinds(manifest);\n\n\t// check the manifest\n\tif (manifest.extensionKind) {\n\t\tconst result: ExtensionKind[] = Array.isArray(manifest.extensionKind)\n\t\t\t? manifest.extensionKind\n\t\t\t: manifest.extensionKind === \"ui\"\n\t\t\t\t? [\"ui\", \"workspace\"]\n\t\t\t\t: [manifest.extensionKind];\n\n\t\t// Add web kind if the extension can run as web extension\n\t\tif (deduced.includes(\"web\") && !result.includes(\"web\")) {\n\t\t\tresult.push(\"web\");\n\t\t}\n\n\t\treturn result;\n\t}\n\n\treturn deduced;\n}\n\nfunction deduceExtensionKinds(manifest: Manifest): ExtensionKind[] {\n\t// Not an UI extension if it has main\n\tif (manifest.main) {\n\t\tif (manifest.browser) {\n\t\t\treturn [\"workspace\", \"web\"];\n\t\t}\n\t\treturn [\"workspace\"];\n\t}\n\n\tif (manifest.browser) {\n\t\treturn [\"web\"];\n\t}\n\n\tlet result: ExtensionKind[] = [\"ui\", \"workspace\", \"web\"];\n\n\tconst isNonEmptyArray = (obj: any) => Array.isArray(obj) && obj.length > 0;\n\t// Extension pack defaults to workspace,web extensionKind\n\tif (isNonEmptyArray(manifest.extensionPack) || isNonEmptyArray(manifest.extensionDependencies)) {\n\t\tresult = [\"workspace\", \"web\"];\n\t}\n\n\tif (manifest.contributes) {\n\t\tfor (const contribution of Object.keys(manifest.contributes)) {\n\t\t\tconst supportedExtensionKinds = extensionPointExtensionKindsMap.get(contribution);\n\t\t\tif (supportedExtensionKinds) {\n\t\t\t\tresult = result.filter(\n\t\t\t\t\t(extensionKind) => supportedExtensionKinds.indexOf(extensionKind) !== -1,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\nclass NLSProcessor extends BaseProcessor {\n\tprivate translations: { [path: string]: string } = Object.create(null);\n\n\tconstructor(manifest: Manifest) {\n\t\tsuper(manifest);\n\n\t\tif (\n\t\t\t!manifest.contributes ||\n\t\t\t!manifest.contributes.localizations ||\n\t\t\tmanifest.contributes.localizations.length === 0\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst localizations = manifest.contributes.localizations;\n\t\tconst translations: { [languageId: string]: string } = Object.create(null);\n\n\t\t// take last reference in the manifest for any given language\n\t\tfor (const localization of localizations) {\n\t\t\tfor (const translation of localization.translations) {\n\t\t\t\tif (translation.id === \"vscode\" && !!translation.path) {\n\t\t\t\t\t// eslint-disable-next-line no-useless-escape\n\t\t\t\t\tconst translationPath = util.normalize(translation.path.replace(/^\\.[\\/\\\\]/, \"\"));\n\t\t\t\t\ttranslations[localization.languageId.toUpperCase()] = `extension/${translationPath}`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// invert the map for later easier retrieval\n\t\tfor (const languageId of Object.keys(translations)) {\n\t\t// @ts-ignore\n\t\t\tthis.translations[translations[languageId]] = languageId;\n\t\t}\n\t}\n\n\tonFile(file: IFile): Promise<IFile> {\n\t\tconst normalizedPath = util.normalize(file.path);\n\t\tconst language = this.translations[normalizedPath];\n\n\t\tif (language) {\n\t\t\tthis.assets.push({\n\t\t\t\ttype: `Microsoft.VisualStudio.Code.Translation.${language}`,\n\t\t\t\tpath: normalizedPath,\n\t\t\t});\n\t\t}\n\n\t\treturn Promise.resolve(file);\n\t}\n}\n\nclass ValidationProcessor extends BaseProcessor {\n\tprivate files = new Map<string, string[]>();\n\tprivate duplicates = new Set<string>();\n\n\tasync onFile(file: IFile): Promise<IFile> {\n\t\tconst lower = file.path.toLowerCase();\n\t\tconst existing = this.files.get(lower);\n\n\t\tif (existing) {\n\t\t\tthis.duplicates.add(lower);\n\t\t\texisting.push(file.path);\n\t\t} else {\n\t\t\tthis.files.set(lower, [file.path]);\n\t\t}\n\n\t\treturn file;\n\t}\n\n\tasync onEnd() {\n\t\tif (this.duplicates.size === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst messages = [\n\t\t\t`The following files have the same case insensitive path, which isn't supported by the VSIX format:`,\n\t\t];\n\n\t\tfor (const lower of this.duplicates) {\n\t\t\tfor (const filePath of this.files.get(lower)!) {\n\t\t\t\tmessages.push(`  - ${filePath}`);\n\t\t\t}\n\t\t}\n\n\t\tthrow new Error(messages.join(\"\\n\"));\n\t}\n}\n\nconst escapeChars = new Map([\n\t[\"'\", \"&apos;\"],\n\t['\"', \"&quot;\"],\n\t[\"<\", \"&lt;\"],\n\t[\">\", \"&gt;\"],\n\t[\"&\", \"&amp;\"],\n]);\n\nfunction escape(value: any): string {\n\treturn String(value).replace(/(['\"<>&])/g, (_, char) => escapeChars.get(char)!);\n}\n\nasync function toVsixManifest(vsix: VSIX): Promise<string> {\n\treturn `<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<PackageManifest Version=\"2.0.0\" xmlns=\"http://schemas.microsoft.com/developer/vsx-schema/2011\" xmlns:d=\"http://schemas.microsoft.com/developer/vsx-schema-design/2011\">\n\t\t<Metadata>\n\t\t\t<Identity Language=\"en-US\" Id=\"${escape(vsix.id)}\" Version=\"${escape(vsix.version)}\" Publisher=\"${escape(\n\t\t\t\tvsix.publisher,\n\t\t\t)}\" ${vsix.target ? `TargetPlatform=\"${escape(vsix.target)}\"` : \"\"}/>\n\t\t\t<DisplayName>${escape(vsix.displayName)}</DisplayName>\n\t\t\t<Description xml:space=\"preserve\">${escape(vsix.description)}</Description>\n\t\t\t<Tags>${escape(vsix.tags)}</Tags>\n\t\t\t<Categories>${escape(vsix.categories)}</Categories>\n\t\t\t<GalleryFlags>${escape(vsix.flags)}</GalleryFlags>\n\t\t\t${\n\t\t\t\t!vsix.badges\n\t\t\t\t\t? \"\"\n\t\t\t\t\t: `<Badges>${vsix.badges\n\t\t\t\t\t\t\t.map(\n\t\t\t\t\t\t\t\t(badge) =>\n\t\t\t\t\t\t\t\t\t`<Badge Link=\"${escape(badge.href)}\" ImgUri=\"${escape(badge.url)}\" Description=\"${escape(\n\t\t\t\t\t\t\t\t\t\tbadge.description,\n\t\t\t\t\t\t\t\t\t)}\" />`,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.join(\"\\n\")}</Badges>`\n\t\t\t}\n\t\t\t<Properties>\n\t\t\t\t<Property Id=\"Microsoft.VisualStudio.Code.Engine\" Value=\"${escape(vsix.engine)}\" />\n\t\t\t\t<Property Id=\"Microsoft.VisualStudio.Code.ExtensionDependencies\" Value=\"${escape(vsix.extensionDependencies)}\" />\n\t\t\t\t<Property Id=\"Microsoft.VisualStudio.Code.ExtensionPack\" Value=\"${escape(vsix.extensionPack)}\" />\n\t\t\t\t<Property Id=\"Microsoft.VisualStudio.Code.ExtensionKind\" Value=\"${escape(vsix.extensionKind)}\" />\n\t\t\t\t<Property Id=\"Microsoft.VisualStudio.Code.LocalizedLanguages\" Value=\"${escape(vsix.localizedLanguages)}\" />\n\t\t\t\t${vsix.preRelease ? `<Property Id=\"Microsoft.VisualStudio.Code.PreRelease\" Value=\"${escape(vsix.preRelease)}\" />` : \"\"}\n\t\t\t\t${\n\t\t\t\t\tvsix.sponsorLink\n\t\t\t\t\t\t? `<Property Id=\"Microsoft.VisualStudio.Code.SponsorLink\" Value=\"${escape(vsix.sponsorLink)}\" />`\n\t\t\t\t\t\t: \"\"\n\t\t\t\t}\n\t\t\t\t${\n\t\t\t\t\t!vsix.links.repository\n\t\t\t\t\t\t? \"\"\n\t\t\t\t\t\t: `<Property Id=\"Microsoft.VisualStudio.Services.Links.Source\" Value=\"${escape(vsix.links.repository)}\" />\n\t\t\t\t<Property Id=\"Microsoft.VisualStudio.Services.Links.Getstarted\" Value=\"${escape(vsix.links.repository)}\" />\n\t\t\t\t${\n\t\t\t\t\tvsix.links.github\n\t\t\t\t\t\t? `<Property Id=\"Microsoft.VisualStudio.Services.Links.GitHub\" Value=\"${escape(vsix.links.github)}\" />`\n\t\t\t\t\t\t: `<Property Id=\"Microsoft.VisualStudio.Services.Links.Repository\" Value=\"${escape(\n\t\t\t\t\t\t\t\tvsix.links.repository,\n\t\t\t\t\t\t\t)}\" />`\n\t\t\t\t}`\n\t\t\t\t}\n\t\t\t\t${\n\t\t\t\t\tvsix.links.bugs\n\t\t\t\t\t\t? `<Property Id=\"Microsoft.VisualStudio.Services.Links.Support\" Value=\"${escape(vsix.links.bugs)}\" />`\n\t\t\t\t\t\t: \"\"\n\t\t\t\t}\n\t\t\t\t${\n\t\t\t\t\tvsix.links.homepage\n\t\t\t\t\t\t? `<Property Id=\"Microsoft.VisualStudio.Services.Links.Learn\" Value=\"${escape(vsix.links.homepage)}\" />`\n\t\t\t\t\t\t: \"\"\n\t\t\t\t}\n\t\t\t\t${\n\t\t\t\t\tvsix.galleryBanner.color\n\t\t\t\t\t\t? `<Property Id=\"Microsoft.VisualStudio.Services.Branding.Color\" Value=\"${escape(\n\t\t\t\t\t\t\t\tvsix.galleryBanner.color,\n\t\t\t\t\t\t\t)}\" />`\n\t\t\t\t\t\t: \"\"\n\t\t\t\t}\n\t\t\t\t${\n\t\t\t\t\tvsix.galleryBanner.theme\n\t\t\t\t\t\t? `<Property Id=\"Microsoft.VisualStudio.Services.Branding.Theme\" Value=\"${escape(\n\t\t\t\t\t\t\t\tvsix.galleryBanner.theme,\n\t\t\t\t\t\t\t)}\" />`\n\t\t\t\t\t\t: \"\"\n\t\t\t\t}\n\t\t\t\t<Property Id=\"Microsoft.VisualStudio.Services.GitHubFlavoredMarkdown\" Value=\"${escape(vsix.githubMarkdown)}\" />\n\t\t\t\t<Property Id=\"Microsoft.VisualStudio.Services.Content.Pricing\" Value=\"${escape(vsix.pricing)}\"/>\n\n\t\t\t\t${\n\t\t\t\t\tvsix.enableMarketplaceQnA !== undefined\n\t\t\t\t\t\t? `<Property Id=\"Microsoft.VisualStudio.Services.EnableMarketplaceQnA\" Value=\"${escape(\n\t\t\t\t\t\t\t\tvsix.enableMarketplaceQnA,\n\t\t\t\t\t\t\t)}\" />`\n\t\t\t\t\t\t: \"\"\n\t\t\t\t}\n\t\t\t\t${\n\t\t\t\t\tvsix.customerQnALink !== undefined\n\t\t\t\t\t\t? `<Property Id=\"Microsoft.VisualStudio.Services.CustomerQnALink\" Value=\"${escape(\n\t\t\t\t\t\t\t\tvsix.customerQnALink,\n\t\t\t\t\t\t\t)}\" />`\n\t\t\t\t\t\t: \"\"\n\t\t\t\t}\n\t\t\t</Properties>\n\t\t\t${vsix.license ? `<License>${escape(vsix.license)}</License>` : \"\"}\n\t\t\t${vsix.icon ? `<Icon>${escape(vsix.icon)}</Icon>` : \"\"}\n\t\t</Metadata>\n\t\t<Installation>\n\t\t\t<InstallationTarget Id=\"Microsoft.VisualStudio.Code\"/>\n\t\t</Installation>\n\t\t<Dependencies/>\n\t\t<Assets>\n\t\t\t<Asset Type=\"Microsoft.VisualStudio.Code.Manifest\" Path=\"extension/package.json\" Addressable=\"true\" />\n\t\t\t${vsix.assets\n\t\t\t\t.map(\n\t\t\t\t\t(asset) =>\n\t\t\t\t\t\t`<Asset Type=\"${escape(asset.type)}\" Path=\"${escape(asset.path)}\" Addressable=\"true\" />`,\n\t\t\t\t)\n\t\t\t\t.join(\"\\n\")}\n\t\t</Assets>\n\t</PackageManifest>`;\n}\n\nconst defaultMimetypes = new Map<string, string>([\n\t[\".json\", \"application/json\"],\n\t[\".vsixmanifest\", \"text/xml\"],\n]);\n\nasync function toContentTypes(files: IFile[]): Promise<string> {\n\tconst mimetypes = new Map<string, string>(defaultMimetypes);\n\n\tfor (const file of files) {\n\t\tconst ext = extname(file.path).toLowerCase();\n\n\t\tif (ext) {\n\t\t// @ts-ignore\n\t\t\tmimetypes.set(ext, mime.lookup(ext));\n\t\t}\n\t}\n\n\tconst contentTypes: string[] = [];\n\tfor (const [extension, contentType] of mimetypes) {\n\t\tcontentTypes.push(`<Default Extension=\"${extension}\" ContentType=\"${contentType}\"/>`);\n\t}\n\n\treturn `<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Types xmlns=\"http://schemas.openxmlformats.org/package/2006/content-types\">${contentTypes.join(\"\")}</Types>\n`;\n}\n\nexport function processFiles(processors: IProcessor[], files: IFile[]): Promise<IFile[]> {\n\tconst processedFiles = files.map((file) =>\n\t\tutil.chain(file, processors, (file, processor) => processor.onFile(file)),\n\t);\n\n\treturn Promise.all(processedFiles).then((files) => {\n\t\treturn util.sequence(processors.map((p) => () => p.onEnd())).then(() => {\n\t\t\tconst assets = processors.reduce<IAsset[]>((r, p) => [...r, ...p.assets], []);\n\t\t\tconst tags = [\n\t\t\t\t...processors.reduce<Set<string>>((r, p) => {\n\t\t\t\t\tfor (const tag of p.tags) {\n\t\t\t\t\t\tif (tag) {\n\t\t\t\t\t\t\tr.add(tag);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn r;\n\t\t\t\t}, new Set()),\n\t\t\t].join(\",\");\n\t\t\tconst vsix = processors.reduce<VSIX>((r, p) => ({ ...r, ...p.vsix }), {\n\t\t\t\tassets,\n\t\t\t\ttags,\n\t\t\t} as VSIX);\n\n\t\t\treturn Promise.all([toVsixManifest(vsix), toContentTypes(files)]).then((result) => {\n\t\t\t\treturn [\n\t\t\t\t\t{ path: \"extension.vsixmanifest\", contents: Buffer.from(result[0], \"utf8\") },\n\t\t\t\t\t{ path: \"[Content_Types].xml\", contents: Buffer.from(result[1], \"utf8\") },\n\t\t\t\t\t...files,\n\t\t\t\t];\n\t\t\t});\n\t\t});\n\t});\n}\n\nexport function createDefaultProcessors(\n\tmanifest: Manifest,\n\toptions: IPackageOptions = {},\n): IProcessor[] {\n\treturn [\n\t\tnew ManifestProcessor(manifest, options),\n\t\tnew TagsProcessor(manifest),\n\t\tnew ReadmeProcessor(manifest, options),\n\t\tnew ChangelogProcessor(manifest, options),\n\t\tnew LaunchEntryPointProcessor(manifest),\n\t\tnew LicenseProcessor(manifest),\n\t\tnew IconProcessor(manifest),\n\t\tnew NLSProcessor(manifest),\n\t\tnew ValidationProcessor(manifest),\n\t];\n}\nexport function writeVsix(files: IFile[], packagePath: string): Promise<void> {\n\tconsole.log(\"Writing VSIX package...\");\n\treturn fs.promises\n\t\t.unlink(packagePath)\n\t\t.catch((err) => (err.code !== \"ENOENT\" ? Promise.reject(err) : Promise.resolve(null)))\n\t\t.then(\n\t\t\t() =>\n\t\t\t\tnew Promise((c, e) => {\n\t\t\t\t\tconst zip = new yazl.ZipFile();\n\t\t\t\t\tfiles.forEach((f) =>\n\t\t\t\t\t\tisInMemoryFile(f)\n\t\t\t\t\t\t\t? zip.addBuffer(\n\t\t\t\t\t\t\t\t\ttypeof f.contents === \"string\" ? Buffer.from(f.contents, \"utf8\") : f.contents,\n\t\t\t\t\t\t\t\t\tf.path,\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tmode: f.mode,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t: zip.addFile(f.localPath, f.path, { mode: f.mode }),\n\t\t\t\t\t);\n\t\t\t\t\tzip.end();\n\n\t\t\t\t\tconst zipStream = fs.createWriteStream(packagePath);\n\t\t\t\t\tzip.outputStream.pipe(zipStream);\n\n\t\t\t\t\tzip.outputStream.once(\"error\", e);\n\t\t\t\t\tzipStream.once(\"error\", e);\n\t\t\t\t\tzipStream.once(\"finish\", () => c());\n\t\t\t\t}),\n\t\t);\n}\n","import { readProjectManifest } from \"@pnpm/cli-utils\";\nimport type { ProjectManifest } from \"@pnpm/types\";\nimport { join } from \"node:path\";\nimport packlist from \"npm-packlist\";\nimport { versionBump } from \"./vsce/version-bump\";\nimport type { Manifest } from \"./vsce/manifest\";\nimport { createDefaultProcessors, processFiles, writeVsix, type IFile, type IPackageOptions } from \"./vsce/package\";\n\nexport interface CreateVsixOptions {\n\tdir: string;\n\toutfile: string;\n\tdryRun?: boolean;\n}\n\nexport async function createVsix(\n\ttarget: { dir: string; outfile: string; dry?: boolean },\n\toptions: IPackageOptions = {},\n) {\n\tconst { manifest, dir } = await getManifest(target.dir);\n\tconst fileNames = await packlist({ path: dir });\n\tconst files = fileNames.map((f) => ({ path: `extension/${f}`, localPath: join(target.dir, f) }));\n\n\tconst { outfile } = target;\n\tif (target.dry) {\n\t\treturn { manifest, outfile, files, dry: true };\n\t}\n\n\tawait versionBump(manifest as Manifest, options);\n\n\tconst processors = createDefaultProcessors(manifest as Manifest, options);\n\tconst processedFiles = await processFiles(processors, files);\n\n\tawait writeVsix(processedFiles, outfile);\n\n\treturn { manifest, outfile, files } as {\n\t\tmanifest: ProjectManifest;\n\t\toutfile: string;\n\t\tfiles: IFile[];\n\t\tdry?: boolean;\n\t};\n}\n\n/** @see https://github.com/pnpm/pnpm/blob/29a2a698060a86459f579572ac6d13151bf294ba/releasing/plugin-commands-publishing/src/pack.ts#L70 */\nconst getManifest = async (packageDir: string) => {\n\tconst { manifest: entryManifest, fileName: manifestFileName } = await readProjectManifest(\n\t\tpackageDir,\n\t\t{},\n\t);\n\n\tconst dir = entryManifest.publishConfig?.directory\n\t\t? join(packageDir, entryManifest.publishConfig.directory)\n\t\t: packageDir;\n\tconst manifest =\n\t\tpackageDir !== dir ? (await readProjectManifest(dir, {})).manifest : entryManifest;\n\n\tif (!manifest.name) {\n\t\tthrow new Error(`Package name is not defined in the ${manifestFileName}.`);\n\t}\n\n\tif (!manifest.version) {\n\t\tthrow new Error(`Package version is not defined in the ${manifestFileName}.`);\n\t}\n\n\treturn { manifest, dir, manifestFileName };\n};\n","import * as core from \"@actions/core\";\nimport { REGISTRIES } from \"./constants\";\nimport * as fs from \"node:fs\";\nimport { createVsix } from \"./vsix\";\nimport { publishVSIX as publishVSCE } from \"@vscode/vsce\";\nimport { publish as publishOVSX } from \"ovsx\"\n\nasync function run() {\n\tconst token = core.getInput(\"token\", {\n\t\trequired: true,\n\t});\n\tconst registry = core.getInput(\"registry\", {\n\t\ttrimWhitespace: true,\n\t});\n\tconst debug = core.getBooleanInput(\"debug\");\n\tconst dryRun = core.getBooleanInput(\"dry-run\");\n\n\tif (debug) {\n\t\tcore.warning(\"running with debug mode enabled\");\n\t}\n\n\tif (dryRun) {\n\t\tcore.warning(\"running with dry-run mode enabled\");\n\t}\n\n\tif (!URL.canParse(registry) && !Object.keys(REGISTRIES).includes(registry)) {\n\t\tcore.setFailed(`invalid registry used: ${registry}`);\n\t\treturn;\n\t}\n\n\tconst extensionPath = core.getInput(\"extensionPath\", {\n\t\ttrimWhitespace: true,\n\t});\n\n\tcore.debug(`extensionPath: ${extensionPath}`);\n\n\tif (!fs.existsSync(extensionPath)) {\n\t\tcore.setFailed(\"extensionPath is not a valid path\");\n\t\treturn;\n\t}\n\n\tconst isFile = fs.lstatSync(extensionPath).isFile();\n\tconst isDirectory = fs.lstatSync(extensionPath).isDirectory();\n\n\tif (!isFile && !isDirectory) {\n\t\tcore.setFailed(\"extensionPath is not a valid path\");\n\t\treturn;\n\t}\n\n\tlet extensionFile: string;\n\tif (!isFile) {\n\t\tconst result = await createVsix({ dir: extensionPath, outfile: \"extension.vsix\", dry: dryRun });\n\n\t\tcore.info(`created vsix at: ${JSON.stringify(result, null, 2)}`);\n\n\t\textensionFile = result.outfile\n\t} else {\n\t\textensionFile = extensionPath;\n\t\tcore.info(\"extension is already packaged, skipping.\")\n\t}\n\n\n\tconst preRelease = core.getBooleanInput(\"pre-release\");\n\n\tif (dryRun) {\n\t\tcore.info(\"dry-run enabled, skipping publish\");\n\t\treturn;\n\t}\n\n\tif (registry === \"vs-marketplace\") {\n\t\tconst result = await publishVSCE(extensionFile, {\n\t\t\tpat: token,\n\t\t\tpreRelease,\n\t\t});\n\n\t\tcore.info(`published to marketplace: ${JSON.stringify(result, null, 2)}`);\n\t} else {\n\t\tthrow new Error(\"registry not supported\");\n\t}\n\n}\n\nrun().catch((err) => {\n\tconsole.error(err);\n\tcore.setFailed(err);\n});\n"],"names":["REGISTRIES","_versionBump","manifest","options","_semver_inc","_options_updatePackageJson","manifestVersion","today","currentVersion","_options_version","rcVersion","command","_options_gitTagVersion","_options_cwd","cwd","_ref","stdout","stderr","Date","semver","Error","__read","promisify","_read","read","prompt","process","Promise","isInMemoryFile","file","_createVsix","target","dir","files","outfile","getManifest","packlist","fileNames","f","_run","token","registry","debug","dryRun","extensionPath","isFile","isDirectory","extensionFile","result","preRelease","result1","core","URL","Object"],"mappings":"mYAAaA,EAAa,CACzB,WAAY,uBACZ,iBAAkB,sCACnB,E,4PCasBC,Q,WAAf,SAA2BC,CAAkB,CAAEC,CAA4B,E,IAuB7DC,EAlBdC,EASAC,EACAC,EACAC,EAOLC,EADKC,EAWFC,EAMEC,EAKMC,EAANC,EACqBC,EAAnBC,EAAQC,E,glCA5ChB,GAAI,CAACd,EAAQ,OAAO,EAIhB,CAAEE,CAAAA,AAAyB,OAAzBA,CAAAA,EAAAA,EAAQ,iBAAiB,AAAD,GAAxBA,AAAAA,KAAAA,IAAAA,GAAAA,CAAgC,GAIlCH,EAAS,OAAO,GAAKC,EAAQ,OAAO,CAPvC,O,GAgBD,GAJMG,EAAkBJ,EAAS,OAAO,CAClCK,EAAQ,IAAIW,OAAO,OAAO,GAAG,QAAQ,GAAG,KAAK,CAAC,EAAG,GAGnD,CAFEV,CAAAA,EAAiBW,EAAO,KAAK,CAACb,EAAe,EAGlD,MAAM,AAAIc,MAAM,2D,IAGXV,CAAAA,EACLD,AAAe,OAAfA,CAAAA,EAAAA,EAAQ,OAAO,AAAD,GAAdA,AAAAA,KAAAA,IAAAA,EAAAA,EAAAA,AAA8C,OAA3BL,CAAAA,EAAAA,EAAO,GAAG,CAACI,EAAgB,QAAO,GAAlCJ,AAAAA,KAAAA,IAAAA,EAAAA,KAAAA,EAAAA,EAAqC,OAAO,CAAC,SAAU,gB,qjBAvBtDH,CAAAA,E,m/CCVtB,IAAMoB,EAASC,AAAAA,CAAAA,EAAAA,EAAAA,SAAAA,AAAAA,EAAiCC,KACzC,SAASC,EAAKC,CAAc,E,IAAEtB,EAAAA,UAAAA,MAAAA,CAAAA,GAAAA,AAAAA,KAAAA,IAAAA,SAAAA,CAAAA,EAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAAyB,CAAC,SAC9D,AAAIuB,QAAQ,GAAG,CAAC,UAAU,EAAI,CAACA,QAAQ,MAAM,CAAC,KAAK,CAC3CC,QAAQ,OAAO,CAAC,KAGjBN,EAAO,A,mUAAA,CAAEI,OAAAA,C,EAAWtB,GAC5B,C,0CAGCuB,QAAQ,GAAG,CAAC,oBAAoB,C,swOCWjC,SAASE,GAAeC,CAAW,EAClC,MAAO,CAAC,CAAC,U,m+1BCdYC,K,MAAAA,CAAAA,GAAf,YACNC,CAAuD,E,IACvD5B,EAE0BY,EAAlBb,EAAU8B,EAEZC,EAEEC,E,wEAJkBnB,OAF1BZ,EAAAA,EAAAA,MAAAA,CAAAA,GAAAA,AAAAA,KAAAA,IAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAA2B,CAAC,EAEFY,C,EAAMoB,GAAYJ,EAAO,GAAG,E,QACpC,OADV7B,EAAkBa,AAAAA,CAAAA,EAAAA,EAAAA,IAAAA,EAAAA,EAAlBb,QAAQ,CAAE8B,EAAQjB,EAARiB,GAAG,CACH,C,EAAMI,IAAS,CAAE,KAAMJ,CAAI,G,WACvCC,EAAQI,AADI,SACM,GAAG,CAAC,SAACC,CAAC,E,MAAM,CAAE,KAAM,uB,4GHJtC,SAA2BpC,CAAkB,CAAEC,CAA4B,E,OAA5DF,EAAAA,KAAAA,CAAAA,IAAAA,CAAAA,U,uuFITPsC,S,WAAf,W,IACOC,EAGAC,EAGAC,EACAC,EAeAC,EAWAC,EACAC,EAOFC,EAEGC,EAWDC,EAQCC,E,glCA7CP,GAjBMV,EAAQW,EAAK,QAAQ,CAAC,QAAS,CACpC,SAAU,EACX,GACMV,EAAWU,EAAK,QAAQ,CAAC,WAAY,CAC1C,eAAgB,EACjB,GACMT,EAAQS,EAAK,eAAe,CAAC,SAC7BR,EAASQ,EAAK,eAAe,CAAC,WAEhCT,GACHS,EAAK,OAAO,CAAC,mCAGVR,GACHQ,EAAK,OAAO,CAAC,qCAGV,CAACC,IAAI,QAAQ,CAACX,IAAa,CAACY,OAAO,IAAI,CAACrD,GAAY,QAAQ,CAACyC,G,OAChEU,EAAK,SAAS,CAAC,qC,oUDZV,SACNpB,CAAuD,E,OADlCD,GAAAA,KAAAA,CAAAA,IAAAA,CAAAA,U,ikBCPPS,CAAAA,G,wNAAAA,GAAAA,KAAAA,CAAAA,IAAAA,CAAAA,U"}